---
- pipeline.id: intake
  queue.type: persisted
  config.string: |
    input { tcp { port => 5401 } }
    output { pipeline { send_to => ["unprocessed-es", "popularity-es"] } }
- pipeline.id: unprocessed-es
  queue.type: persisted
  config.string: |
    input { pipeline { address => "unprocessed-es" } }
    filter { json { source => "message" } date { match => ["timestamp", "UNIX_MS"] } mutate { remove_field => [ "message" ] } }
    output { elasticsearch { hosts => [ "elasticsearch:9200" ] index => "logstash-new-%{+YYYY.MM.dd}" }
        elasticsearch {
            hosts => [ "https://es-alicecs1.cern.ch:443/es/" ]
            index => "alicecs1-jalien-%{+YYYY.MM.dd}"
            user => "logstash"
            password => "${ES_LOGSTASH_PASSWORD}"
            ssl => "true"
            cacert => "/config-dir/ca/cern_grid_cert.pem"
        }
    }
- pipeline.id: popularity-es
  queue.type: persisted
  config.string: |
     input { pipeline { address => "popularity-es" } }
     filter { json { source => "message" } date { match => ["timestamp", "UNIX_MS"] } mutate { remove_field => [ "message" ] }
       ruby {
         code => '
         command = event.get("command")
         event_args = event.get("arguments")
         if ((command == "access" or command == "PFNforReadOrDel") and event_args.include? "read")
           arguments = []
           arguments.push(event_args).flatten!
           arguments.each do |i|
           if i.start_with?("/alice/")
               event.set("file_path", i)
               event.set("found", "true")
             end
           end
         end
         '
       }
       if [found] != "true" {
         drop { }
       }
       prune {
         whitelist_names => ["^file_path$"]
       }
     }
     output {
         elasticsearch {
             hosts => [ "elasticsearch:9200" ]
             index => "popularity-%{+YYYY.MM.dd}"
         }
     }


